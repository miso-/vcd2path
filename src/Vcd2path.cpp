#include "Vcd2path.h"

#include "ui_Vcd2path.h"
#include "PrintBedView/PrintBedViewWidget.h"
#include "SignalAssignment/SignalAssignmentDia.h"
#include "Signal.h"
#include "StepperDriver.h"
#include "PrinterState.h"

extern "C" {
#include "gtkwave/vcd.h"
#include "gtkwave/globals.h"
#include "gtkwave/symbol.h"
#include "gtkwave/analyzer.h"
#include "gtkwave/tree.h"
}

#include <QtGui/QLabel>
#include <QtGui/QMenu>
#include <QtGui/QMenuBar>
#include <QtGui/QAction>
#include <QFileDialog>
#include <QMessageBox>
#include <QHBoxLayout>
#include <QGraphicsEllipseItem>
#include <QPointF>
#include <QSettings>
#include <QDir>
#include <QPair>

Vcd2path::Vcd2path()
	: ui(new Ui::Vcd2path()),
	  m_printBedView(new PrintBedViewWidget(this, this)),
	  m_sigs(),
	  m_drivers(),
	  m_currState(0),
	  m_stateTrace()
{
	ui->setupUi(this);
	QHBoxLayout *l = new QHBoxLayout();
	l->addWidget(m_printBedView);
	ui->centralwidget->setLayout(l);
}

Vcd2path::~Vcd2path()
{
	delete ui;
}

const QVector<QSharedPointer<StepperDriver> > &Vcd2path::drivers() const
{
	return m_drivers;
}

const QVector<PrinterState> &Vcd2path::stateTrace() const
{
	return m_stateTrace;
}

void Vcd2path::on_action_Open_triggered()
{
	QSettings settings;

	QString vcdFilename = QFileDialog::getOpenFileName(this, tr("Open File"), settings.value("last_file").toString(), tr("Supported files(*.vcd);;All files(*.*)"));

	if (!vcdFilename.isEmpty()) {
		QFile vcdFile(vcdFilename);

		if (!vcdFile.open(QIODevice::ReadOnly | QIODevice::Text)) {
			QMessageBox::critical(this, tr("Error"), tr("Unable to open vcd file."));
			return;
		}

		QDir dir;
		settings.setValue("last_file", dir.absoluteFilePath(vcdFilename));


		if (GLOBALS) {
			free(GLOBALS);
			// TODO: Deallocate data structures referenced from GLOBALS.
			// WARNING: Memory leak here.
		}

		GLOBALS = initialize_globals();

		vcd_main(vcdFilename.toUtf8().constData());
		SignalAssignmentDia axisSettings;
		if (axisSettings.exec()) {
			m_sigs = axisSettings.getSignals();
			m_drivers = axisSettings.stepperDrivers();

			if (m_currState) {
				for (int i = 0; i < m_drivers.size(); ++i) {
					m_drivers[i]->unbindPrinterState();
				}
				delete m_currState;
			}
			m_currState = new PrinterState;
			m_stateTrace.clear();

			for (int i = 0; i < m_drivers.size(); ++i) {
				m_drivers[i]->bindToPrinterState(m_currState, i);
			}
			createTrace();
			m_printBedView->reloadData();
		}
	}
}

void Vcd2path::on_action_Quit_triggered()
{
	close();
}

void Vcd2path::on_action_About_triggered()
{
	QMessageBox aboutBox(this);
	aboutBox.setWindowTitle(tr("About"));
	aboutBox.setTextFormat(Qt::RichText);
	aboutBox.setText("<h1><center>vcd2path</center></h1>\
<center><small>Copyright (C) 2014  miso-</small></center>\
<br />\
<br />\
Simple tool for visualising signals generated by reprap firmware.\
<br />\
<br />\
<br />\
<br />\
This program is free software; you can redistribute it and/or modify \
it under the terms of the GNU General Public License as published by \
the Free Software Foundation; either version 2 of the License, or \
(at your option) any later version.<br />\
<br />\
This program is distributed in the hope that it will be useful, \
but WITHOUT ANY WARRANTY; without even the implied warranty of \
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \
GNU General Public License for more details.<br />\
<br />\
You should have received a copy of the GNU General Public License \
along with this program.  If not, see <a href=http://www.gnu.org/licenses>http://www.gnu.org/licenses</a>.\
<br />");
	aboutBox.exec();
}


void Vcd2path::createTrace()
{
	// Create list of signals to monitor.

	typedef QPair<hptr, QSharedPointer<Signal> > p_t;
	QVector<p_t> facs;

	foreach (QSharedPointer<Signal> sig, m_sigs) {
		if (sig->facNo() < 0 || sig->facNo() >= GLOBALS->numfacs) {
			continue;
		}
		hptr h = GLOBALS->facs[sig->facNo()]->n->head.next;
		if (h) {
			p_t p(h, sig);
			facs.push_back(p);
		}
	}

	// Process the list.

	TimeType currTime = 0;

	while (1) {
		// Find signal that changes its value next.
		TimeType nextTime = LONG_MAX;
		QVector<p_t >::iterator nextSig = facs.end();
		for (QVector<p_t >::iterator i = facs.begin(); i != facs.end(); ++i) {

			while (i->first && i->first->time < currTime) {
				i->first = i->first->next;
			}

			if (i->first && i->first->time < nextTime) {
				nextTime = i->first->time;
				nextSig = i;
			}
		}

		currTime = nextTime;

		if (nextSig == facs.end()) {
			break;
		}

		// TODO: Check signal type (v.h_val).
		nextSig->second->changeValue(nextSig->first->v.h_val, currTime);
		nextSig->first = nextSig->first->next;
		m_stateTrace.push_back(*m_currState);
	}
}
